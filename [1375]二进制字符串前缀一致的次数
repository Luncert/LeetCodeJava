// BitSet实现
class Solution {
    private final int WORD_CAP = 64;
    private long WORD_MAX_VALUE = 0; // 补码是-1

    public int numTimesAllBlue(int[] flips) {
        for (int i = 0; i < WORD_CAP; i++) {
            WORD_MAX_VALUE |= 1L << i; // 1 << i 和 1L << i结果不同，因为溢出的时机不同
        }

        int count = 0;
        long[] bits = new long[flips.length / WORD_CAP + 1];
        boolean lastMatched = false;
        for (int i = 0; i < flips.length; i++) {
            int bit = flips[i] - 1;
            int wordIndex = bit / WORD_CAP;
            bits[wordIndex] |= 1L << (bit % WORD_CAP);

            // bit必须小于等于i才可能match
            if (bit > i) {
                lastMatched = false;
                continue;
            } else if (lastMatched) {
                count++;
                continue;
            }

            if (hasSamePrefix(bits, i)) {
                count++;
                lastMatched = true;
            } else {
                lastMatched = false;
            }
        }

        return count;
    }

    private boolean hasSamePrefix(long[] bits, int step) {
        int wordIndex = step / WORD_CAP;
        for (int j = 0; j < wordIndex; j++) {
            if (bits[j] != WORD_MAX_VALUE) {
                return false;
            }
        }
        long word = bits[wordIndex];
        for (int j = 0; j <= step % WORD_CAP; j++) {
            if ((word & (1L << j)) == 0) {
                return false;
            }
        }
        return true;
    }
}
